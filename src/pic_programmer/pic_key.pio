// This program sends a 32 bit word to the target device in a single continuous stream of bits
.program pic_key
.side_set 1 opt

	pull block
bitloop:
	out pins, 1			side 1	[1]		; Shift 1 bit from OSR to the first OUT pin
	jmp !OSRE bitloop	side 0	[1]		; Loop until OSR is empty

	; Return something
	in null, 32			side 1	[1]		; Raise clock for final stop bit (0)
	push block			side 0			; Finally, pull down clock for final stop bit (0)

% c-sdk {

static inline void pic_key_program_init(PIO pio, uint sm, uint prog_offs, float clkdiv,
	uint pin_clock, uint pin_data) {

	// NOTE: Setting pin directions and values first to avoid sending garbage to the target device

	// Set pin directions (pin_clock and pin_data are always outputs)
	pio_sm_set_pindirs_with_mask(
		pio, sm,
		(1u << pin_clock) | (1u << pin_data),
		(1u << pin_clock) | (1u << pin_data));

	// Set default pin values (everything is low)
	pio_sm_set_pins_with_mask(
		pio, sm, 
		0,
		(1u << pin_clock) | (1u << pin_data));

	// Claim pins for PIO
	pio_gpio_init(pio, pin_clock);
	pio_gpio_init(pio, pin_data);

	pio_sm_config c = pic_key_program_get_default_config(prog_offs);

	sm_config_set_out_pins(&c, pin_data, 1); 		// Set base pin and number of pins for OUT operand
	sm_config_set_sideset_pins(&c, pin_clock);		// Set sideset base pin

	sm_config_set_clkdiv(&c, clkdiv);

	// hw_set_bits(&pio->input_sync_bypass, 1u << pin_miso); // TODO this disables flip-flops on the input pins for faster inputs, useful?

	// Initialize the state machine
	pio_sm_init(pio, sm, prog_offs, &c);
	pio_sm_set_enabled(pio, sm, true);
}

%}