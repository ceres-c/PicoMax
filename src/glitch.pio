.program glitch_trigger
.side_set 1 opt

	set pins, 1 side 0 [7]
	set pins, 0 side 1

% c-sdk {

static inline void glitch_trigger_program_init(PIO pio, uint sm, uint prog_offs,
	bool trig_out_enabled, uint pin_max_sel, uint pin_trig_in, uint pin_trig_out) {

	pio_sm_config c = glitch_trigger_program_get_default_config(prog_offs);

	sm_config_set_out_pins(&c, pin_max_sel, 1);
	sm_config_set_in_pins(&c, pin_trig_in);
	sm_config_set_sideset_pins(&c, pin_trig_out);

	// sm_config_set_clkdiv(&c, clkdiv); // TODO is this useful in any way? float clkdiv

	// Set default pin values (pin_trigger_out is low, pin_max_sel is high)
	pio_sm_set_pins_with_mask(
		pio, sm, 
		(1u << pin_max_sel),
		(1u << pin_trig_out) | (1u << pin_max_sel));

	// Set pin directions (pin_trigger_out and pin_max_sel are outputs, pin_trigger_in is an input)
	pio_sm_set_pindirs_with_mask(
		pio, sm,
		(trig_out_enabled & (1u << pin_trig_out)) | (1u << pin_max_sel),
		(trig_out_enabled & (1u << pin_trig_out)) | (1u << pin_max_sel) | (1u << pin_trig_in));

	// Configure pin functions to PIO
	pio_gpio_init(pio, pin_trig_in);
	pio_gpio_init(pio, pin_trig_out);
	pio_gpio_init(pio, pin_max_sel);

	// Use GPIO pin muxes to invert the output. It's easier to think of the glitch as 0->1->0 rather than 1->0->1.
	gpio_set_outover(pin_max_sel, GPIO_OVERRIDE_INVERT); // NOTE: this MUST be here after the inits

	// hw_set_bits(&pio->input_sync_bypass, 1u << pin_miso); // TODO this disables flip-flops on the input pins for faster inputs, useful?

	// Initialize the state machine
	pio_sm_init(pio, sm, prog_offs, &c);
	pio_sm_set_enabled(pio, sm, true);
}

%}